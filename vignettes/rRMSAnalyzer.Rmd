---
title: "rRMSAnalyzer: package to analyze RiboMethSeq data"
author: "Théo COMBE, Hermès PARAQINDES, Allyson MOUREAUX, Janice KIELBASSA, Fleur BOURDELAIS, Sébastien DURAND, Emilie THOMAS, Anthony FERRARI and Virginie MARCEL"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
abstract: > 
  RiboMethSeq is an innovative RNAseq-based approach, which was developed in 2015 to analyze 2’O-ribose methylation (2’Ome) at all sites of ribosomal RNAs (rRNA) at once, in yeast [@birkedal2014]. This approach was then adapted to user customed rRNA using the Illumina technology [@Marchand2016; @Erales2017; @Marcel2021]. Concretely, 2'Ome methylation is the addition of a methyl group at the 2'position of the ribose in a ribosomal DNA site. A methylation at the n site protects the phosphodiester bond at the n+1 site from alkaline hydrolysis. Consequently, the cleavage does not appear homogeneously on all sites as expected when there is no methylation. The presence of 2'Ome at nucleotide n leads to under-representation of RNA fragments beginning at nucleotide n+1, and over-representation of RNA fragments ending at nucleotide n-1. This allows the detection of methylation and the measurement of the 2'Ome level, also known as the C-score. The C-score is computed for all DNA sites and can vary from 0 to 1 (Birkedal et al., 2014). A value of 0 indicates that no ribosomes are methylated at the position of interest, while a value of 1 indicates that all ribosomes are methylated. Heterogeneity of methylation is observed between 0 and 1. For example, a value of 0.5 indicates that half of the ribosomes in the experiment are methylated and half are not at the position of interest. <br> The rRMSAnalyzer package can be used for any kind of RNA and with all organisms. Human data is provided in the tool but other personal data can be uploaded. This package provides a set of user-friendly functions to (i) compute C-scores from RiboMethSeq read-end counts as input,(ii) perform quality control of the dataset, (iii) adjust batch effect with ComBat-Seq, and (iv) provide tools to visualize, analyze the data and provide a table with the annotated human rRNA sites and their C-scores (Paraqindes et al., 2023). Raw data processing to obtain read-end counts from sequencing data can be performed using our Nextflow pipeline [ribomethseq-nf](https://github.com/RibosomeCRCL/ribomethseq-nf), as already described [@Marchand2016].
output:
   rmarkdown::html_vignette:
      toc: true
      number_sections: true
      fig_width: 5
      fig_height: 5
vignette: >
  %\VignetteIndexEntry{rRMSAnalyzer: package to analyze RiboMethSeq data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include=FALSE}
library(dplyr)
library(DT)
library(kableExtra)
library(rRMSAnalyzer)
```

# General information 

## Help, bug reports and suggestions

To report a bug or any suggestion to improve the package, please let us know by opening a new issue on: https://github.com/RibosomeCRCL/rRMSAnalyzer/issues

## Acknowledgements

We would like to thank all our collaborators for their advice and suggestions.

## Funding

This project has been funded by the French Cancer Institute (INCa, PLBIO 2019-138 MARACAS), the SIRIC Program (INCa-DGOS-Inserm_12563 LyRICAN) and [Synergie Lyon Cancer Foundation](https://www.synergielyoncancer.fr).

## Installation

The latest version of rRMSAnalyzer package can be installed from Github with :

```{r, eval = FALSE}
devtools::install_github("RibosomeCRCL/rRMSAnalyzer")
# devtools::install_github("RibosomeCRCL/rRMSReports")
library(rRMSAnalyzer)
# library(rRMSReports)
```

# Initial preparation of the dataset

## RiboClass

RiboClass is the main class of the package that enables the storage of both the data matrices (read-end counts and C-scores) and the associated metadata. It is automatically created when calling *`load_ribodata()`* (see [Loading data]).

It is a list containing three main elements, as described below:

1.  **Data**: a *list of dataframe*, containing for each sample the 5' and/or 3' read-end counts provided by the user, and the calculated C-score.

2.  **Metadata**: a *dataframe*, containing all the information related to the samples that can be provided by the user.

3.  **rRNA_names**: a *dataframe*, reporting the names of the rRNA used in Data.

Some major function parameters (such as the normalization method used for C-score computation) are also kept in the RiboClass object as a reminder.

## Loading data

### Data to provide {-}

#### Read-end counts {-}

To use this package, the user must provide at least one csv/tsv file with the 5', 3' or 5'/3' read-end counts resulting from RiboMethSeq data per sample. The folder structure containing the csv files is not important, as long as either the directory and its sub-directories contain the necessary csv/tsv files.

1.  The **name of the rRNA** on which the read end counting was performed.

2.  The **position's number** on the rRNA.

3.  The **value of the read-end counts** at the position.

Here is an example :

| rRNA | Position on rRNA | read end count |
|-----|-----------------|----------------|
| 18S | 123             | 3746           |
| 18S | 124             | 345            |
| 18S | 125             | 324            |
| 18S | 126             | 789            |
| 18S | 127             | 1234           |

Note 1: it is not necessary to provide a header in the count files, because column index can be used in the function *load_ribodata()*, using *`count_value()`*, *`count_rnaid()`* and *`count_pos()`* parameters.

Note 2: if no metadata is specified (metadata = NULL), rRMSAnalyzer will try to fetch any csv files in the folder specified in count_path and its subfolders.

#### Metadata {-}

The expected metadata is either a dataframe already in the R environment or a csv/tsv file.

[Two columns are mandatory for the metadata :]{.underline}

1.  **filename**: name of the csv file on disk containing the read-end counts described above. Do not modify it unless the filename has changed on disk.

2.  **samplename**: rename the samples that will be analyzed and displayed on the plots. This column can be modified, as long as the sample names are unique.

After these two mandatory columns, the user can provide as many columns as needed for the analysis.

Here is an example of metadata for 3 samples:

+--------------+--------------+----------------------+
| filename     | samplename   | condition            |
|              |              |                      |
| (mandatory)  | (mandatory)  | (optional)          |
+==============+==============+======================+
| sample1.csv  | sample 1     | condition 1          |
+--------------+--------------+----------------------+
| sample2.csv  | sample 2     | condition 1          |
+--------------+--------------+----------------------+
| sample3.csv  | sample 3     | condition 2          |
+--------------+--------------+----------------------+

Note: if no metadata is provided in *`load_ribodata()`* (metadata = NULL), an empty metadata will be created with the “filename” and “samplename” columns pre-filled. The “samplename” column will be identical to “filename”, but can be modified by the user.

Here is an example of auto-generated metadata:

| filename    | samplename  |
|-------------|-------------|
| sample1.csv | sample1.csv |
| sample2.csv | sample2.csv |
| sample3.csv | sample3.csv |

#### How to load the data {-}

To load both data and metadata, and store them in a RiboClass, the function *`load_ribodata()`* is used.

The following example displays a call to *`load_ribodata()`*, with all parameters shown :

```{r}
path <- system.file("extdata", package="rRMSAnalyzer")

ribo <- load_ribodata(
                      #data & metadata files path
                      count_path = file.path(path,"miniglioma/"),
                      metadata = file.path(path,"metadata.csv"),
                      # data & metadata files separator
                      count_sep = "\t",
                      metadata_sep = ",",
                      # count data parameters :
                      count_header = FALSE,
                      count_value = 3,
                      count_rnaid = 1,
                      count_pos = 2,
                      # Metadata parameters :
                      metadata_key = "filename",
                      metadata_id = "samplename",
                      # C-score parameters :
                      flanking = 6,
                      method = "median",
                      ncores = 1)
```


## rRNA names {-}

### Provided {-}

rRNA names are automatically obtained from the data and stored in a generated dataframe inside the RiboClass. It contains two columns :

1.  **original_name**: original name of each rRNA (e.g NR_023363.1).

2.  **current_name**: current name of each rRNA, reflecting any user's change with *`rename_rna()`* function (see [Rename RNA]).

This dataframe is used to keep track of the original name, which often includes the NCBI’s accession ID.

Here is an example:

| original_name    | current_name |
|------------------|--------------|
| NR_023363.1_5S   | 5S           |
| NR_046235.3_5.8S | 5.8S         |
| NR_046235.3_18S  | 18S          |
| NR_046235.3_28S  | 28S          |

### Custom {-}

The user must not modify this dataframe manually. To rename or remove rRNA, the user can use *`rename_rna()`* and *`remove_rna()`*. The dataframe will be updated accordingly.

## C-score calculation

### What is a C-score ? {-}

The C-score is a metric, calculated from the RiboMethSeq sequencing data, used to evaluate the level of 2’O-ribose methylation (2’Ome) at a given position in the rRNA. 

The C-score is calculated by normalizing the end read count with respect to the local environment at each genomic position and directly indicates the rRNA 2’Ome level. The C-score ranges from 0 (i.e., no rRNA molecules of the sample are 2’Ome at this specific site) to 1 (i.e., all rRNA molecules of the sample are 2’Ome at this specific site). A C-score with an intermediate value between 0 to 1 means that the sample contains a mixture of un-2’Ome and 2’Ome rRNA molecules. 

To obtain a robust estimate of the 2’Ome level, different C-scores can be determined depending on the parameters used to compute the local coverage. In particular, the estimation method and the size of the local coverage to be considered can be changed.

By default, the local coverage is estimated by calculating the **median** of the **5' read-end counts** in a **flanking region of 6** (i.e., 6 nucleotides downstream the nucleotide n and 6 upstream the nucleotide n, where n is the nucleotid directly following the 2’Ome site of interest). This package provides the ability to change these two parameters either when loading the data or during the analysis.

#### C-score computation when loading data {-}

When using the *`load_ribodata()`* function, a C-score is automatically calculated for all genomic positions of the rRNA. The C-score is computed using either the default parameters of the *`load_ribodata()`* function or user-defined parameters as follows:

```{r, eval=FALSE}
load_ribodata(count.path = "/path/to/csv/",
              metadata = "/path/to/metadata.csv",
              # everything below is linked to C-score computation
              flanking = 6, # flanking region size
              method = "median", # use mean or median on flanking region's values
              ncores = 8 # number of CPU cores to use for computation
              )
```

#### C-score computation during the analysis {-}

During the analysis, the C-score calculating parameters (method and size of the flanking region) can be modified using the *`compute_cscore()`* function, which will automatically update the C-score in the RiboClass.

In the following example, both the flanking region's size of the local coverage and the computation method have been modified:

```{r,eval=FALSE}
# Compute the C-score using different parameters,
# including calculation of the local coverage using the mean instead of the median
ribo <- compute_cscore(ribo,
                       flanking = 4,
                       method = "mean")

```

**Important: this function will override the previous C-score of the RiboClass.**

# Quality control

Due to technical limitations, it is sometimes necessary to conduct wet-lab preparations of large cohorts in several batches.
The main risk when making several batches is to introduce **technical biases** or **batch effect** in the dataset.

## Content of the QC report 

A quality control (QC) report can be performed. It uses several metrics to help identify outlier samples and/or batch effects, including read-end counts and the C-score itself at all the 7217 genomic positions. The QC verifies that the coverage is uniform and reproducible between samples, eliminating the possibility of bias due to sequencing and outliers. 

QC can be either performed using a panel of ready to use functions, which correspond to data visualization, or automatically.

The automatic QC report can be generated using the *`report_qc()`* function:

With the ribo_toy example, the column that contains the information about samples batches is called "run". The name is thus given to the *`library_col`* parameter but it can be also left empty.

```{r, eval=FALSE}
report_qc(ribo = ribo_toy, library_col = "run")
```

The QC report includes the following visualizations:

- read-end counts distribution by sample (*`boxplot_count()`*)
- Relative log coverage (i.e., end read count) by sample (*`plot_rlc()`*)
- rRNA fraction of read-end counts per sample (*`plot_count_fraction()`*)
- Heatmap summarizing the correlation matrix of the read-end counts (*`heatmap_annotated()`*)
- Correspondence analysis of the read-end counts (*`plot_coa()`*)
- Principal component analysis (*`plot_pca()`*)

### Correlation matrix {-}

To get outlier annotation on the heatmap, *`get_outliers()`* function has to be used. This function compute all outliers of the experiment returning a data frame as a summary used in the *`plot_heatmap_annotated()`*

```{r}
qcdata <- rRMSAnalyzer::get_outliers(ribo)
```

```{r, fig.asp = 0.9, fig.width = 7 ,fig.height=12}
plot_heatmap_annotated(ribo, qcdata)
```

### Output of the quality control report {-}

```{r}
output_dir <- getwd()
```

To save the output: 
```{r, eval = FALSE}
write.table(qcdata,file.path(output_dir,"quality_control.csv"),sep="\t",row.names=FALSE,quote = FALSE)
```

To display the output:
```{r, warning=FALSE}
knitr::kable(qcdata, "html") %>% kable_styling("striped") %>% scroll_box(width = "100%", height = "500px")
```

### Comments {-}

To add some comments in the Comments section of the report, a Rmarkdown file has to be created and saved in the working directory. Path to this report has to be given in the comments argument of the function to be included in the final report. 

```{r, eval = FALSE}
report_qc(ribo = ribo, specie = "human", library_col = "run", comments = "./path/to/comment_QC.Rmd")
```

Below an example of comment file in rmd extension that can be copied and pasted in an rmd file:

```{r, eval = FALSE, echo = TRUE, asis = TRUE}
```{=html} 
<style type="text/css">
  body {
    font-family: Helvetica;
  }

  /* Apply a skyblue background to the blocks <details> */
  details {
    background-color: #9ecae1;
    padding: 10px;
    border-radius: 5px;
  }
</style>
``` #
<details>

  <summary><b> ℹ Comments on the report  </b></summary>
  <div markdown="1">
<p>
Text can be entered from here ...

Subtitle can be added with '##' symbol:

## 2.1 Level 2 title {-} #this symbol {-} avoid continue the numbering of the table of content

Some text.
## 2.2 Level 2 title {-}

Some texte again. Sub sub title can be added with '###' symbol:

## 2.2.1 Level 3 title {-}

...to here. Those last 2 lines below must be kept. They are usefull for the layout.
</div>
</details>
```

## Batch effect 

### Batch effect identification {-}

Technical bias (i.e., batch effect) can be identified by plotting C-scores at all the genomic positions of the rRNA for each sample on a PCA (see also [Visualization with PCA] for more uses).

Since more than 1.5% of the C-score corresponds to non-biological noise, normalization during C-score calculation should limit the dispersion of the samples based on their C-score at all genomic positions in the whole series. Thus, Principal Component Analysis (PCA) on C-scores helps to identify putative batch effects that can be corrected using the inter-normalization option (ComBat-seq tool) (Zhang et al, 2020; Paraqindes et al, 2023). 
<br> <br>
The graph shows a Principal Component Analysis (PCA) plot illustrating the distance between each sample based on its C-score at all genomic positions. The samples are colored by library.

Here is an example:

```{r}
# Plot a Principal Component Analysis (PCA) whose colors depend on the "run" column in metadata
plot_pca(ribo = ribo,
         color_col = "run")
```

In this example, the technical replicates RNA1 and RNA2 included in library 1 and 2 respectively, are distant from each other on the PC1 axis. Moreover, the samples should not be grouped by library or batch. The following section will resolve this batch effect.

### Batch effect adjustment {-}

Batch effect of RiboMethSeq data can be adjusted using the ComBat-seq method (Paraqindes et al, 2023 ; Zhang, et al, 2020). The rRMSAnalyzer package includes a wrapper (adjust_bias) to perform ComBat-seq adjustment which provides a new RiboClass with adjusted read end count values and C-scores automatically recalculated with the same setup parameters.

```{r}
data("ribo_toy")
# If necessary, adjust any technical biases using ComBat-Seq.
# Here, as an example, we use the "run" column in metadata.
ribo_adjusted <- adjust_bias(ribo_toy, batch = "run")
```

Batch effect adjustment can be verified using the plot_pca function on the new RiboClass:

```{r}
plot_pca(ribo_adjusted,"run")
```

After batch effect adjustment using ComBat-seq method, the two technical replicates RNA1 and RNA2 show reduced dispersion, and the samples are separated on the PCA axes independently of the library they belong to.

## Verifying local coverage

The C-score depends on the local coverage around the site. For a simple visualization of the read end count coverage of the flanking region of a given genomic position of interest, use the `plot_counts_env()` function. 
Two plotting methods are available:

1. **display all samples** (default parameters): by displaying the end read count coverage of all samples using a boxplot at the +/-6 genomic position relative to the genomic position of interest (green box). A pink box is displayed if there is other modification in the window. Such a plot is automatically used when samples = "all". The median of the read end count and coverage limit are shown as two dashed red lines.

Here is an example:

```{r}
plot_counts_env(ribo_adjusted,"NR_046235.3_5.8S",14)
```

2. **sample of interest**: by displaying the end read count coverage of the sample of interest only using the profile at the +/-6 genomic position relative to the genomic position of interest (vertical green line). The median of the read end count is displayed as a horizontal dotted red line.

Here is an example:

```{r}
plot_counts_env(ribo_adjusted,"NR_046235.3_5.8S",14,c("S1","S2"))
```

# Data formatting for subsequent analyses

## Sample manipulation

### Keep or remove samples {-}

A sample subset can be easily analyzed by specifying which samples to keep or which to remove. The user can then create a new RiboClass object containing the data and metadata of the samples of interest. In both cases, only the metadata of the remaining samples are kept in the RiboClass object, so no manual updating is required.

Here is an example of how to create a new RiboClass by retaining two samples of interest (“S1” and “S2”):

```{r}
ribo_2samples <- keep_ribo_samples(ribo_adjusted,c("S1","S2"))
print(ribo_2samples)
```

Here is an example to generate a new RiboClass by removing two samples ("RNA1" and "RNA2"):

```{r}
ribo_adjusted <- remove_ribo_samples(ribo_adjusted,c("RNA1","RNA2"))
print(ribo_adjusted)
```

In both cases, only the remaining samples' metadata are kept in the RiboClass object. There is no need to update it manually.

## rRNA manipulation and annotation

### rRNA manipulation {-}

#### Remove rRNA {-}

A subset of rRNA can be easily analyzed by specifying the rRNA to be removed. The user can thus create a new RiboClass object containing the data of the rRNAs of interest, without affecting the metadata of the samples.

Here is an example where the rRNA 5S is removed:

```{r}
ribo_adjusted <- remove_rna(ribo, rna_to_remove = "NR_023363.1_5S")
print(ribo_adjusted)
```

### Rename rRNA

The annotation of rRNA 2’Ome sites using the lists provided by this package requires the use of specific rRNA names.

Here is an example to check if the rRNA names provided by the user in the RiboClass match the ones used by this package :

```{r}
data("human_methylated")
cat("human_methylated's rna names: ", unique(human_methylated$rRNA),"\n")
cat("ribo's rna names: ", as.character(ribo_adjusted$rna_names$current_name))
```

In this example, the names are different and need to be updated before annotation.

The `rename_rna()` function automatically updates the rRNA names given by the rRNA size order:

```{r}
ribo_adjusted <- rename_rna(ribo_adjusted,
                            new_names = c("5.8S", "18S", "28S")) 
                            # from the shortest rRNA in our RiboClass to the longest.

```

## Annotation of rRNA 2'Ome sites

The rRMSAnalyzer package calculates a C-score for each genomic position of the rRNAs. However, not every site of the reference 2’Ome rRNA is necessarily methylated. Therefore, it is expected that the user provides a list of potentially methylated sites of interest, called “annotated sites”. This will make it easier to restrict further analysis to this list of sites. By default, rRMSAnalyzer package includes its own human annotated sites.

### Included annotation : Human 2'Ome rRNA sites {-}

By default, rRMSAnalyzer package includes two dataframes containing the positions and the annotations of the human rRNA 2’Ome sites:

-   human_methylated: a dataframe, containing the 112 known 2'Ome sites for the human rRNAs.

-   human_suspected: a dataframe, containing the 17 sites that are putative 2'Ome sites for the human rRNAs, as described in the litterature.

-   human_both_methylated_and_suspected: a dataframe, containing the 129 sites of both known 2'Ome sites and sites that are putative 2'Ome sites for the human rRNAs.


### Customize 2'Ome sites annotations {-}

Instead of using the list of human rRNA 2’Ome sites provided by the rRMSAnalyzer package, the user can provide their own list of annotated sites which will be attached to the RiboClass object using the `annotate_site()` function (see Section : annotation of rRNA 2'Ome sites).

This `annotate_site()` function expects an “annot” parameter which must be a dataframe object that contains the following three mandatory columns :

-   **RNA name**: the name of the rRNA, matching the rRNA name of the RiboClass.

-   **Position on RNA**: the number of the position on the rRNA.

-   **Nomenclature**: the name given to the site of interest.

You can see an example below :

| Position | rRNA | Nomenclature |
|----------|------|--------------|
| 15       | 5.8S | Um14         |
| 76       | 5.8S | Gm75         |
| 28       | 18S  | Am27         |

### Annotate rRNA sites {-}

The 2’Ome sites of interest must be attached to the RiboClass object for further analysis using the `annotate_site()` function with either the provided annotations or custom annotations (see [Customize 2'Ome sites annotations]).

Here is an example using the included human methylated annotations:

```{r}
ribo_adjusted <- annotate_site(ribo_adjusted,
                               annot = human_methylated,
                               anno_rna = "rRNA",
                               anno_pos = "Position",
                               anno_value = "Nomenclature")
```

Note : rRMSAnalyzer will display a warning message when there is a mismatch between the annot and RiboClass rRNA names. 

This vignette also provides some explanations on how to create your own sites annotation dataset with [Customize 2'Ome sites annotations].

## Analysis design

If you planned to run functions from the *diff_sites* report (see [Site-by-site comparison of 2'Ome levels report]), this section needs to be considered. 
If you have several experimental designs of condition that you want to compare individually, this section part (1) has to be considered before using functions of / generate *2ome_analysis* report (see [2'Ome profiling report]). 

### Comparison table and supplementary metadata columns {-}

(1) The metadata are in the RiboClass object after its creation. It allows us to create "copy" of the RiboClass but with a subset of the samples. An example has been created to help you define the structure of the columns you need to create.
Note: To change metadata, change the metadata file used to create the RiboClass (see [How to load the data]) and create it once again with the function *load_ribodata()*. 

In this example there is 3 experimental conditions named A, B, C. <br>
- VariableA (9 samples)  has 1 control and 2 cases (P1 and P2) with 3 replicates for each. <br>
- VariableB (4 samples) has 1 control and 1 case (P2) with 2 replicates for each. <br>
- VariableC (6 samples) has 1 control and 1 case (P2) with 3 replicates for each. <br>

In the case we want to explore differences within each experimental conditions between case and control we need to create 3 supplementary columns that will define samples to compare. Then, we will be able to use each new 3 Riboclass in the 2ome_analysis report and the diff_sites report (thus, generate each report 3 times). We start with an example of metadata as below (metadata in the initial RiboClass):

+-----------------------+----------------------+-------------+-----------+-----+
| filename              | samplename           | condition   | treatment | lib |
+=======================+======================+=============+===========+=====+
| S26_R1.5_counts.csv   | variableB_N2_P2      | variableB   | P2        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S27_R1.5_counts.csv   | variableA_N2_P1      | variableA   | P1        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S28_R1.5_counts.csv   | variableC_N1_ctrl    | variableC   | ctrl      | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S30_R1.5_counts.csv   | variableB_N1_P2      | variableB   | P2        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S31_R1.5_counts.csv   | variableC_N2_P2      | variableC   | P2        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S32_R1.5_counts.csv   | variableA_N3_P1      | variableA   | P1        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S33_R1.5_counts.csv   | variableA_N3_ctrl    | variableA   | ctrl      | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S34_R1.5_counts.csv   | variableC_N3_ctrl    | variableC   | ctrl      | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S35_R1.5_counts.csv   | variableA_N1_P2      | variableA   | P2        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S36_R1.5_counts.csv   | variableA_N2_ctrl    | variableA   | ctrl      | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S37_R1.5_counts.csv   | variableC_N2_ctrl    | variableC   | ctrl      | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S38_R1.5_counts.csv   | variableA_N2_P2      | variableA   | P2        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S39_R1.5_counts.csv   | variableC_N1_P2      | variableC   | P2        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S40_R1.5_counts.csv   | variableB_N1_ctrl    | variableB   | ctrl      | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S41_R1.5_counts.csv   | variableA_N1_P1      | variableA   | P1        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S42_R1.5_counts.csv   | variableA_N1_ctrl    | variableA   | ctrl      | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S43_R1.5_counts.csv   | variableC_N3_P2      | variableC   | P2        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S44_R1.5_counts.csv   | variableB_N2_ctrl    | variableB   | ctrl      | L2  |
+-----------------------+----------------------+-------------+-----------+-----+
| S45_R1.5_counts.csv   | variableA_N3_P2      | variableA   | P2        | L2  |
+-----------------------+----------------------+-------------+-----------+-----+

To analyse each condition we add some columns. The metadata now, contain 3 supplementary columns "variableA", "variableB", "variableC" that define our experimental design to analyse individually:

+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| filename              | samplename           | variableA | variableB | variableC | condition   | treatment | lib |
+=======================+======================+===========+===========+===========+=============+===========+=====+
| S26_R1.5_counts.csv   | variableB_N2_P2      | NA        | P2        | NA        | variableB   | P2        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S27_R1.5_counts.csv   | variableA_N2_P1      | P1        | NA        | NA        | variableA   | P1        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S28_R1.5_counts.csv   | variableC_N1_ctrl    | NA        | NA        | ctrl      | variableC   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S30_R1.5_counts.csv   | variableB_N1_P2      | NA        | P2        | NA        | variableB   | P2        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S31_R1.5_counts.csv   | variableC_N2_P2      | NA        | NA        | P2        | variableC   | P2        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S32_R1.5_counts.csv   | variableA_N3_P1      | P1        | NA        | NA        | variableA   | P1        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S33_R1.5_counts.csv   | variableA_N3_ctrl    | ctrl      | NA        | NA        | variableA   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S34_R1.5_counts.csv   | variableC_N3_ctrl    | NA        | NA        | ctrl      | variableC   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S35_R1.5_counts.csv   | variableA_N1_P2      | P2        | NA        | NA        | variableA   | P2        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S36_R1.5_counts.csv   | variableA_N2_ctrl    | ctrl      | NA        | NA        | variableA   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S37_R1.5_counts.csv   | variableC_N1_ctrl    | NA        | NA        | ctrl      | variableC   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S38_R1.5_counts.csv   | variableA_N2_P2      | P2        | NA        | NA        | variableA   | P2        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S39_R1.5_counts.csv   | variableC_N2_P2      | NA        | NA        | P2        | variableC   | P2        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S40_R1.5_counts.csv   | variableB_N1_ctrl    | NA        | ctrl      | NA        | variableB   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S41_R1.5_counts.csv   | variableA_N1_P1      | P1        | NA        | NA        | variableA   | P1        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S42_R1.5_counts.csv   | variableA_N1_ctrl    | ctrl      | NA        | NA        | variableA   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S43_R1.5_counts.csv   | variableC_N3_P2      | NA        | NA        | P2        | variableC   | P2        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S44_R1.5_counts.csv   | variableB_N3_ctrl    | NA        | ctrl      | NA        | variableB   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+
| S45_R1.5_counts.csv   | variableA_N3_P2      | P2        | NA        | NA        | variableA   | P2        | L2  |
+-----------------------+----------------------+-----------+-----------+-----------+-------------+-----------+-----+

We can imagine another design where we want to compare all P2 cases vs. all control. In this case we will create a new column "comp1" for example with all P2 and all ctrl (if they are biologically the same) and NA for P1 samples.

+-----------------------+----------------------+-------+-----------+-----------+-----+
| filename              | samplename           | comp1 | condition | treatment | lib |
+=======================+======================+=======+===========+===========+=====+
| S26_R1.5_counts.csv   | variableB_N2_P2      | P2    | variableB | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S27_R1.5_counts.csv   | variableA_N2_P1      | NA    | variableA | P1        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S28_R1.5_counts.csv   | variableC_N1_ctrl    | ctrl  | variableC | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S30_R1.5_counts.csv   | variableB_N1_P2      | P2    | variableB | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S31_R1.5_counts.csv   | variableC_N2_P2      | P2    | variableC | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S32_R1.5_counts.csv   | variableA_N3_P1      | NA    | variableA | P1        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S33_R1.5_counts.csv   | variableA_N3_ctrl    | ctrl  | variableA | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S34_R1.5_counts.csv   | variableC_N3_ctrl    | ctrl  | variableC | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S35_R1.5_counts.csv   | variableA_N1_P2      | P2    | variableA | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S36_R1.5_counts.csv   | variableA_N2_ctrl    | ctrl  | variableA | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S37_R1.5_counts.csv   | variableC_N1_ctrl    | ctrl  | variableC | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S38_R1.5_counts.csv   | variableA_N2_P2      | P2    | variableA | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S39_R1.5_counts.csv   | variableC_N2_P2      | P2    | variableC | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S40_R1.5_counts.csv   | variableB_N1_ctrl    | ctrl  | variableB | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S41_R1.5_counts.csv   | variableA_N1_P1      | NA    | variableA | P1        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S42_R1.5_counts.csv   | variableA_N1_ctrl    | ctrl  | variableA | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S43_R1.5_counts.csv   | variableC_N3_P2      | P2    | variableC | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S44_R1.5_counts.csv   | variableB_N3_ctrl    | ctrl  | variableB | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S45_R1.5_counts.csv   | variableA_N3_P2      | P2    | variableA | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+

If we want to compare P1 and P2 vs. ctrl, we need to create a new column where P1 and P2 have a new common name. We can imagine "P" for P1 and P2 samples that we will compared to ctrl. 

+-----------------------+----------------------+-------+-----------+-----------+-----+
| filename              | samplename           | comp1 | condition | treatment | lib |
+=======================+======================+=======+===========+===========+=====+
| S26_R1.5_counts.csv   | variableB_N2_P2      | P     | variableB | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S27_R1.5_counts.csv   | variableA_N2_P1      | P1    | variableA | P1        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S28_R1.5_counts.csv   | variableC_N1_ctrl    | ctrl  | variableC | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S30_R1.5_counts.csv   | variableB_N1_P2      | P     | variableB | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S31_R1.5_counts.csv   | variableC_N2_P2      | P     | variableC | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S32_R1.5_counts.csv   | variableA_N3_P1      | P1    | variableA | P1        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S33_R1.5_counts.csv   | variableA_N3_ctrl    | ctrl  | variableA | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S34_R1.5_counts.csv   | variableC_N3_ctrl    | ctrl  | variableC | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S35_R1.5_counts.csv   | variableA_N1_P2      | P     | variableA | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S36_R1.5_counts.csv   | variableA_N2_ctrl    | ctrl  | variableA | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S37_R1.5_counts.csv   | variableC_N1_ctrl    | ctrl  | variableC | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S38_R1.5_counts.csv   | variableA_N2_P2      | P     | variableA | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S39_R1.5_counts.csv   | variableC_N2_P2      | P     | variableC | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S40_R1.5_counts.csv   | variableB_N1_ctrl    | ctrl  | variableB | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S41_R1.5_counts.csv   | variableA_N1_P1      | P1    | variableA | P1        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S42_R1.5_counts.csv   | variableA_N1_ctrl    | ctrl  | variableA | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S43_R1.5_counts.csv   | variableC_N3_P2      | P     | variableC | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S44_R1.5_counts.csv   | variableB_N3_ctrl    | ctrl  | variableB | ctrl      | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+
| S45_R1.5_counts.csv   | variableA_N3_P2      | P     | variableA | P2        | L2  |
+-----------------------+----------------------+-------+-----------+-----------+-----+

(2) The comparison table is a dataframe containing all the biological comparisons to perform during the report diff_site. This one is to be created by a piece of code (below).   

Here is an example of a comparison table for two comparisons (case of variableA analysis): 

+-----------+------------+------------+
| comp      | ctrl       | cases      |
|           |            |            |
|(mandatory)| (mandatory)| (mandatory)|
+===========+============+============+
|   comp1   |   ctrl     |   P1       |
|(mandatory)|            |            |
+-----------+------------+------------+
|   comp2   |   ctrl     |   P2       |
|(optional) |            |            |
+-----------+------------+------------+

This table will be used exclusively in the diff_sites report functions or to generate the latter. 

Note: as the comparisons are done with respect to this table in the report diff_site, the latter can contain as much lines as the number of comparison expected for the analysis.

The following example displays how to create the dataframe for the report diff_site (also present in the Model_murine.Rmd / Model_human.Rmd scripts provided in a tabset):

```{r, eval = FALSE}
#----------- (1) part 1 (metadata) of this subsection is used here--------------
# store the subset sammples thanks to the columns created in metadata before
kept_samples <- ribo_adj_annot$metadata %>% #here we suppose that a RiboClass is already created and annotated 
  dplyr::filter(!is.na(variableA)) %>% #we filter the lines in metadata to keep only those which are not NA in the column "variableA"
  dplyr::pull(samplename)

# create a copy of the RiboClass with a subset of samples
ribo_adj_annot_variableA <- keep_ribo_samples(ribo_adj_annot,kept_samples) #Then we save the new riboclass only with sample from variableA column

#----------- (2) part 2 (comparison table) of this subsection is used here------
# Here is the comparison table needed for this example data
comparisons <- tibble::tibble(
  comp = c("comp1", "comp2"),
  ctrl = c("ctrl", "ctrl"),
  cases = c("P1", "P2")
)
```

Now the ribo_adj_annot_variableA contain this metadata after the code is executed:

+-----------------------+----------------------+-----------+-------------+-----------+-----+
| filename              | samplename           | variableA | treatment   | condition | lib |
+=======================+======================+===========+=============+===========+=====+
| S27_R1.5_counts.csv   | variableA_N2_P1      | P1        | variableA   | P1        | L2  |
+-----------------------+----------------------+-----------+-------------+-----------+-----+
| S32_R1.5_counts.csv   | variableA_N3_P1      | P1        | variableA   | P1        | L2  |
+-----------------------+----------------------+-----------+-------------+-----------+-----+
| S33_R1.5_counts.csv   | variableA_N3_ctrl    | ctrl      | variableA   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-------------+-----------+-----+
| S35_R1.5_counts.csv   | variableA_N1_P2      | P2        | variableA   | P2        | L2  |
+-----------------------+----------------------+-----------+-------------+-----------+-----+
| S36_R1.5_counts.csv   | variableA_N2_ctrl    | ctrl      | variableA   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-------------+-----------+-----+
| S38_R1.5_counts.csv   | variableA_N2_P2      | P2        | variableA   | P2        | L2  |
+-----------------------+----------------------+-----------+-------------+-----------+-----+
| S41_R1.5_counts.csv   | variableA_N1_P1      | P1        | variableA   | P1        | L2  |
+-----------------------+----------------------+-----------+-------------+-----------+-----+
| S42_R1.5_counts.csv   | variableA_N1_ctrl    | ctrl      | variableA   | ctrl      | L2  |
+-----------------------+----------------------+-----------+-------------+-----------+-----+
| S45_R1.5_counts.csv   | variableA_N3_P2      | P2        | variableA   | P2        | L2  |
+-----------------------+----------------------+-----------+-------------+-----------+-----+

Note: As the copy of the RiboClass is now created, it has to be used in the "ribo" argument for all the functions in diff_sites. The comparison table follows the same logic. When the argument "comparison" is asked in a report or a function, it is this table that has to be given. 

If there is only one column condition, it is still the same thing. Here in the metadata example we can see 3 column variables. They are the different comparisons that are wanted to be analysed. You can replace the name for your custom ones. You can also run the analysis on the "condition" column. In this case analysis will be done comparing as many modalities as you have in the same report (!! be aware that even in this case you need a comparison table for the diff_site analysis). (The treatment column is optional)

# 2'Ome profiling report

A 2'Ome profile report (2ome_analysis) can be performed. It uses several metrics to help identify global profile of methylation between biological conditions. 

```{r, eval = FALSE}
report_2ome_sites(ribo = ribo_adjusted, specie = "human", condition_col = "condition", project_name = "name_of_project", comments = "./path/to/comments_for_this_report.Rmd")
```

To determine whether rRNA 2’Ome profiles are different between conditions and identify the most variable rRNA 2’Ome sites, several functions have been implemented to obtain a ggplot. Moreover, the parameter `only_annotated`, which is included in all the plot related functions, enables the plotting of only the annotated rRNA 2’Ome sites of interest (i.e., with biological relevance) when set to true.
Here is a list of the implemented plots with the function name:

- principal component analysis using the C-scores of the annotated rRNA 2’Ome sites (`plot_pca()`)
- heatmap using the C-scores of the annotated rRNA 2’Ome sites (`plot_heatmap()`)
- boxplot using the C-scores of the annotated rRNA 2’Ome sites in descending order of variability (`boxplot_cscores()`)
- scatterplot using the Interquartile Range (IQR) of the annotated rRNA 2’Ome sites in descending order of variability. A Gauss curve is added on the right side using the IQR distribution allowing to identify the most variable sites in red (`plot_sites_by_IQR()`)  
In addition, a function to provide a summary of the metrics computed in the report is generated as a data frame using *(`get_2ome_summary()`)*

### PCA {-}

As an example, the *`plot_pca()`* function is presented below.  

Here is an example comparing samples reflecting different biological conditions based on the rRNA 2’Ome profile of the provided human_methylated list:

```{r}
plot_pca(ribo_adjusted,
         color_col = "condition",
         only_annotated = TRUE)
```

**Note 1** : by default, PC1 and PC2 axes are plotted. However, the user can choose the PCA axes of interest using the "axes" parameter.

```{r}
plot_pca(ribo_adjusted,
         color_col = "condition",
         axes = c(2,3), #PC2 and PC3 will be plotted
         only_annotated = TRUE)
```

**Note 2**  the function returns the complete dudi.pca _object_ (`dudi.pca()` function from ade4 library) instead of the plot by setting *object_only* to TRUE:

```{r}
pca <- plot_pca(ribo_adjusted,
         color_col = "condition",
         only_annotated = TRUE,
         object_only = TRUE)
```

### Comments {-}

To add some comments in the Comments section of the report, a Rmarkdown file has to be created and saved in the working directory. Path to this report has to be given in the comments argument of the function to be included in the final report. 

```{r, eval = FALSE}
report_2ome_sites(ribo_adjusted, specie = "human", condition_col = "condition", project_name = "name_of_project", comments =  "./path/to/comments_for_this_report.Rmd") 
```

# Site-by-site comparison of 2'Ome levels report 

A differential site analysis (diff_site) report can be added to the two previous report to refine the analysis on 2'Ome. It uses several metrics and tests to identify differentially methylated sites that can discriminate between biological condition / variable. To run these functions a comparison table (see how to create it below) and supplementary metadata columns needs to be done (see [Comparison table and supplementary metadata columns])

```{r, eval = FALSE}
# !! usefull only for the diff site report create the necessary comparison table for the diff_sites report
comparisons <- tibble::tibble(
  comp = c("comp1"),
  ctrl = c("cond1"),
  cases = c("cond2")
)
```

The diff_sites report includes the following visualization:

- 2'Ome Global Profile (*`plot_global_profile()`*)
- Representation of Differential median C-score with the combination of two graphs for each comparisons present in the table provided for this report (*`plot_comparison_median()`*)
- Boxplot of differential sites done with several possible (ANOVA, Welch, Kruskal-Wallis, Wilcoxon) statistical tests related to the number of variable (*`plot_stat()`*) <br>
In addition, a *`get_diff_sites_summary()`* gives the summary of significant sites in a least one statistical test. 

## Summary table of statistical tests {-}

To get a table of significant sites in at least one test the function below can be used.

```{r, eval = FALSE}
get_diff_sites_summary(ribo = ribo_toy, condition_col = "comp1", comparisons = comparisons)
```

## Comments {-}

```{r, eval = FALSE}
report_diff_sites(ribo = ribo_toy, specie = "human", condition_col = "comp1", comparisons = comparisons, comments = "./path/to/comments_for_this_report.Rmd") 
```

# Exporting data

Data can be exported as two different objects in three different ways.

## Export as a dataframe

The user can export data as a dataframe using the *`extract_data()`* function.

By default, C-scores for all the genomic rRNA positions are exported.

```{r}
ribo_df <- extract_data(ribo_adjusted,
                        col = "cscore")
```

The user can export data related to the subset of annotated rRNA 2'Ome sites by setting the `only_annotated` parameter to TRUE.

```{r}
ribo_df <- extract_data(ribo_adjusted,
                        col = "cscore",
                        only_annotated = TRUE)
```

```{r, echo=FALSE}
knitr::kable(ribo_df[1:10,1:4],caption = "Excerpt from the output dataframe, where S1, S2 and S3 are samples:")
```

## Export as a ggplot-ready dataframe {-}

The user can export data as a ggplot-ready dataframe using the *`format_to_plot()`* function.

By default, C-scores for all the genomic rRNA positions are exported. The user can export additional information contained in the metadata by specifying the name of the column of interest. The user can export information related to the subset of annotated rRNA 2’Ome sites by setting the *only_annotated* parameter to TRUE.

Here is an example of ggplot-ready dataframe containing the C-scores of all the genomic rRNA positions as well as the condition related to the particular sample of interest:

```{r}
ggplot_table <- format_to_plot(ribo = ribo_adjusted, metadata_col = "condition", only_annotated = FALSE)
```

```{r,echo=FALSE}
knitr::kable(ggplot_table[501:510,], caption = "Excerpt from the output ggplot-ready dataframe")
```

## Export as a dataframe by condition {-}

The *`mean_samples_by_condition()`* function regroup all the genomic rRNA positions by condition and compute mean and standard deviation for each condition. Then it displays a table.

By default, the function provides the metrics of the C-scores. By setting the *value* parameter to "count", it is also possible to calculate these values from the read-end counts. Calculations can be limited to only annotated rRNA 2’Ome sites by setting the *only_annotated* parameter to TRUE.

Here is an example of dataframe showing the summarized C-scores per modality of the “condition” variable for all the genomic rRNA positions:

```{r}
mean_tb <- mean_samples_by_conditon(ribo_adjusted,
                                    value = "cscore", #or "count"
                                    metadata_condition = "condition",
                                    only_annotated = TRUE)
```

```{r,echo=FALSE}
knitr::kable(mean_tb[1:10,], caption = "Excerpt from the output dataframe by condition")
```

# Session info

```{r}
sessionInfo()
```

# References
